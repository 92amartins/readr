# This file was generated by Rcpp::compileAttributes
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

collectorGuess <- function(input) {
    .Call('readr_collectorGuess', PACKAGE = 'readr', input)
}

read_connection_ <- function(con, chunk_size = 64 * 1024L) {
    .Call('readr_read_connection_', PACKAGE = 'readr', con, chunk_size)
}

utctime <- function(year, month, day, hour, min, sec, psec, repair = FALSE) {
    .Call('readr_utctime', PACKAGE = 'readr', year, month, day, hour, min, sec, psec, repair)
}

date_time_locale <- function() {
    .Call('readr_date_time_locale', PACKAGE = 'readr')
}

#' Parse a character vector of dates.
#'
#' @section Format specification:
#' \code{readr} uses a format specification similiar to \code{\link{strptime}}.
#' There are three types of element:
#'
#' \enumerate{
#'   \item Date components are specified with "\%" followed by a letter.
#'     For example "\%Y" matches a 4 digit year, "\%m", matches a 2 digit
#'     month and "\%d" matches a 2 digit day.
#'   \item Whitespace is any sequence of zero or more whitespace characters.
#'   \item Any other character is matched exactly.
#' }
#'
#' \code{parse_datetime} recognises the following format specifications:
#' \itemize{
#'   \item Year: "\%Y" (4 digits). "\%y" (2 digits); 00-69 -> 2000-2069,
#'     70-99 -> 1970-1999.
#'   \item Month: "\%m" (2 digits).
#'   \item Day: "\%d" (2 digits), "\%e" (optional leading space)
#'   \item Hour: "\%H"
#'   \item Minutes: "\%M"
#'   \item Seconds: "\%S" (integer seconds), "\%OS" (partial seconds)
#'   \item Time zone: "\%Z" (as name, e.g. "America/Chicago"), "\%z" (as
#'     offset from UTC, e.g. "+0800")
#'   \item Non-digits: "\%." skips one non-digit charcter, "\%*" skips any
#'     number of non-digits characters.
#'   \item Shortcuts: "\%D" = "\%m/\%d/\%y",  "\%F" = "\%Y-\%m-\%d",
#'       "\%R" = "\%H:\%M", "\%T" = "\%H:\%M:\%S",  "\%x" = "\%y/\%m/\%d".
#' }
#'
#' @param dates A character vector of dates to parse.
#' @param format A format specification, as described below. If omitted,
#'   parses dates according to the ISO8601 specification.
#'
#'   Unlike \code{\link{strptime}}, the format specification must match
#'   the complete string.
#' @param tz Default tz. This is used both for input (if the time zone isn't
#'   present in individual strings), and for output (to control the default
#'   display). The default is to use "UTC", a time zone that does not use
#'   daylight savings time (DST) and hence is typically most useful for data.
#'   The absense of time zones makes it approximately 50x faster to generate
#'   UTC times than any other time zone.
#'
#'   Use \code{""} to use the system default time zone, but beware that this
#'   will not be reproducible across systems.
#'
#'   For a complete list of possible time zones, see \code{\link{OlsonNames}()}.
#'   Americans, note that "EST" is a Canadian time zone that does not have
#'   DST. It is \emph{not} Eastern Standard Time. It's better to use
#'   "US/Eastern", "US/Central" etc.
#' @param repair If \code{TRUE}, will attempt to repair invalid dates
#'   like "2000-02-31". Repair works from smallest to largest, first ensuring
#'   seconds lies between 0 and 59, then minutes between 0-59 etc.
#' @return A \code{\link{POSIXct}} vector with \code{tzone} attribute set to
#'   \code{tz}. Elements that could not be parsed (or did not generate valid
#'   dates) will bes set to \code{NA}, and a warning message will inform
#'   you of the total number of failures.
#' @export
#' @examples
#' # Format strings --------------------------------------------------------
#' parse_datetime("01/02/2010", "%d/%m/%Y")
#' parse_datetime("01/02/2010", "%m/%d/%Y")
#' # Handle any separator
#' parse_datetime("01/02/2010", "%m%.%d%.%Y")
#'
#' # You can parse timezones from strings (as listed in OlsonNames())
#' parse_datetime("2010/01/01 12:00 US/Central", "%Y/%m/%d %H:%M %Z")
#' # Or from offsets
#' parse_datetime("2010/01/01 12:00 -0600", "%Y/%m/%d %H:%M %z")
#'
#' # Use the tz parameter to control the default time zone
#' # (but note UTC is considerably faster than other options)
#' parse_datetime("2010/01/01 12:00", "%Y/%m/%d %H:%M", tz = "US/Central")
#' parse_datetime("2010/01/01 12:00", "%Y/%m/%d %H:%M", tz = "US/Eastern")
#'
#' # Unlike strptime, the format specification must match the complete
#' # string (ignoring leading and trailing whitespace). This avoids common
#' # errors:
#' strptime("01/02/2010", "%d/%m/%y")
#' parse_datetime("01/02/2010", "%d/%m/%y")
#'
#' # ISO8601 --------------------------------------------------------------
#' # With separators
#' parse_datetime("1979-10-14")
#' parse_datetime("1979-10-14T10")
#' parse_datetime("1979-10-14T10:11")
#' parse_datetime("1979-10-14T10:11:12")
#' parse_datetime("1979-10-14T10:11:12.12345")
#'
#' # Without separators
#' parse_datetime("19791014")
#' parse_datetime("19791014T101112")
#'
#' # Time zones
#' parse_datetime("1979-10-14T1010", tz = "US/Central")
#' parse_datetime("1979-10-14T1010-0500", tz = "US/Central")
#' parse_datetime("1979-10-14T1010Z", tz = "US/Central")
parse_datetime <- function(dates, format = "", tz = "UTC", repair = FALSE) {
    .Call('readr_parse_datetime', PACKAGE = 'readr', dates, format, tz, repair)
}

dim_tokens_ <- function(sourceSpec, tokenizerSpec) {
    .Call('readr_dim_tokens_', PACKAGE = 'readr', sourceSpec, tokenizerSpec)
}

count_fields_ <- function(sourceSpec, tokenizerSpec) {
    .Call('readr_count_fields_', PACKAGE = 'readr', sourceSpec, tokenizerSpec)
}

tokenize_ <- function(sourceSpec, tokenizerSpec, n_max) {
    .Call('readr_tokenize_', PACKAGE = 'readr', sourceSpec, tokenizerSpec, n_max)
}

#' Parse a character vector.
#'
#' @param x Character vector of elements to parse.
#' @param collector Column specification.
#' @keywords internal
#' @export
#' @examples
#' x <- c("1", "2", "3", NA)
#' parse_vector(x, col_integer())
#' parse_vector(x, col_double())
#' parse_vector(x, col_character())
#' parse_vector(x, col_skip())
#'
#' # Invalid values are replaced with missing values with a warning.
#' x <- c("1", "2", "3", "-")
#' parse_vector(x, col_double())
parse_vector <- function(x, collectorSpec) {
    .Call('readr_parse_vector', PACKAGE = 'readr', x, collectorSpec)
}

read_file_ <- function(sourceSpec) {
    .Call('readr_read_file_', PACKAGE = 'readr', sourceSpec)
}

read_lines_ <- function(sourceSpec, n_max = -1L) {
    .Call('readr_read_lines_', PACKAGE = 'readr', sourceSpec, n_max)
}

read_tokens <- function(sourceSpec, tokenizerSpec, colSpecs, col_names, n_max = -1L, progress = TRUE) {
    .Call('readr_read_tokens', PACKAGE = 'readr', sourceSpec, tokenizerSpec, colSpecs, col_names, n_max, progress)
}

collectorsGuess <- function(sourceSpec, tokenizerSpec, n = 100L) {
    .Call('readr_collectorsGuess', PACKAGE = 'readr', sourceSpec, tokenizerSpec, n)
}

whitespaceColumns <- function(sourceSpec, n = 100L) {
    .Call('readr_whitespaceColumns', PACKAGE = 'readr', sourceSpec, n)
}

type_convert_col <- function(x, spec, col) {
    .Call('readr_type_convert_col', PACKAGE = 'readr', x, spec, col)
}

stream_csv <- function(df, path, col_names = TRUE, append = FALSE) {
    .Call('readr_stream_csv', PACKAGE = 'readr', df, path, col_names, append)
}

