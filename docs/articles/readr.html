<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Vignette Title &bull; readr</title><!-- jquery --><script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script><!-- Bootstrap --><link href="../tidyverse.css" rel="stylesheet"><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><!-- Font Awesome icons --><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous"><!-- tidyverse --><link href="../pkgdown.css" rel="stylesheet"><script src="../jquery.sticky-kit.min.js"></script><script src="../pkgdown.js"></script><!-- mathjax --><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]--></head><body>
    <div class="container template-vignette">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>

      <div class="navbar-brand-container">
        <a class="navbar-brand" href="../index.html">readr</a>
        <small class="tidyverse">part of the <a href="http://tidyverse.org">tidyverse</a></small>
      </div>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav navbar-right"><li>
  <a href="../index.html">Home</a>
</li>
<li>
  <a href="../articles/readr.html">Overview</a>
</li>
<li>
  <a href="../articles/locales.html">Locales</a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li>
  <a href="../news/index.html">News</a>
</li>
        <li>
  <a href="https://github.com/tidyverse/readr">
    <span class="fa fa-github fa-lg"></span>
     
  </a>
</li>
      </ul></div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

      
      </header><div class="row">
  <div class="col-md-9">
    <div class="page-header toc-ignore">
      <h1>Vignette Title</h1>
            
            <h4 class="date">2016-10-27</h4>
          </div>

    
    
<div class="contents">
<p>The key problem that readr solves is <strong>parsing</strong> a flat file into a tibble. Parsing is the process of taking a text file and turning it into a rectangular tibble where each column is the appropriate part. Parsing takes place in three basic stages:</p>
<ol style="list-style-type: decimal"><li><p>The flat file is parsed into a rectangular matrix of strings.</p></li>
<li><p>The type of each column is determined.</p></li>
<li><p>Each column of strings is parsed into a vector of a more specific type.</p></li>
</ol><p>It&rsquo;s easiest to learn how this works in the opposite order Below, you&rsquo;ll learn how the:</p>
<ol style="list-style-type: decimal"><li><p><strong>Vector parsers</strong> turn a character vector in to a more specific type.</p></li>
<li><p><strong>Column specification</strong> describes the type of each column and the strategy readr uses to guess types so you don&rsquo;t need to supply them all.</p></li>
<li><p><strong>Rectangular parsers</strong> turn a flat file into a matrix of rows and columns.</p></li>
</ol><p>Each <code>parse_*()</code> is coupled with a <code>col_*()</code> function, which will be used in the process of parsing a complete tibble.</p>
<div id="vector-parsers" class="section level2">
<h2 class="hasAnchor"><html><body><a href="#vector-parsers" class="anchor"> </a></body></html>Vector parsers</h2>
<p>It&rsquo;s easiest to learn the vector parses using <code>parse_</code> functions. These all take a character vector and some options. They return a new vector the same length as the old, along with an attribute describing any problems.</p>
<div id="atomic-vectors" class="section level3">
<h3 class="hasAnchor"><html><body><a href="#atomic-vectors" class="anchor"> </a></body></html>Atomic vectors</h3>
<p><code><a href="../reference/parse_atomic.html">parse_logical()</a></code>, <code><a href="../reference/parse_atomic.html">parse_integer()</a></code>, <code><a href="../reference/parse_atomic.html">parse_double()</a></code>, and <code><a href="../reference/parse_atomic.html">parse_character()</a></code> are straightforward parsers that produce the corresponding atomic vector.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/parse_atomic.html">parse_integer</a></span>(<span class="kw">c</span>(<span class="st">"1"</span>, <span class="st">"2"</span>, <span class="st">"3"</span>))
<span class="co">#&gt; [1] 1 2 3</span>
<span class="kw"><a href="../reference/parse_atomic.html">parse_double</a></span>(<span class="kw">c</span>(<span class="st">"1.56"</span>, <span class="st">"2.34"</span>, <span class="st">"3.56"</span>))
<span class="co">#&gt; [1] 1.56 2.34 3.56</span>
<span class="kw"><a href="../reference/parse_atomic.html">parse_logical</a></span>(<span class="kw">c</span>(<span class="st">"true"</span>, <span class="st">"false"</span>))
<span class="co">#&gt; [1]  TRUE FALSE</span></code></pre></div>
<p>By default, readr expects <code>.</code> as the decimal mark and <code>,</code> as the grouping mark. You can override this default using <code><a href="../reference/locale.html">locale()</a></code>, as described in <code><a href="../articles/locales.html">vignette("locales")</a></code>.</p>
</div>
<div id="flexible-numeric-parser" class="section level3">
<h3 class="hasAnchor"><html><body><a href="#flexible-numeric-parser" class="anchor"> </a></body></html>Flexible numeric parser</h3>
<p><code><a href="../reference/parse_atomic.html">parse_integer()</a></code> and <code><a href="../reference/parse_atomic.html">parse_double()</a></code> are strict: the input string must be a single number with no leading or trailing characters. <code><a href="../reference/parse_number.html">parse_number()</a></code> is more flexible: it ignores non-numeric prefixes and suffixes, and knows how to deal with grouping marks. This makes it suitable for reading currencies and percentages:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/parse_number.html">parse_number</a></span>(<span class="kw">c</span>(<span class="st">"0%"</span>, <span class="st">"10%"</span>, <span class="st">"150%"</span>))
<span class="co">#&gt; [1]   0  10 150</span>
<span class="kw"><a href="../reference/parse_number.html">parse_number</a></span>(<span class="kw">c</span>(<span class="st">"$1,234.5"</span>, <span class="st">"$12.45"</span>))
<span class="co">#&gt; [1] 1234.50   12.45</span></code></pre></div>
</div>
<div id="datetimes" class="section level3">
<h3 class="hasAnchor"><html><body><a href="#datetimes" class="anchor"> </a></body></html>Date/times</h3>
<p>readr supports three types of date/time data:</p>
<ul><li>dates: number of days since 1970-01-01.</li>
<li>times: number of seconds since midnight.</li>
<li>datetimes: number of seconds since midnight 1970-01-01.</li>
</ul><div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/parse_datetime.html">parse_datetime</a></span>(<span class="st">"2010-10-01 21:45"</span>)
<span class="co">#&gt; [1] "2010-10-01 21:45:00 UTC"</span>
<span class="kw"><a href="../reference/parse_datetime.html">parse_date</a></span>(<span class="st">"2010-10-01"</span>)
<span class="co">#&gt; [1] "2010-10-01"</span>
<span class="kw"><a href="../reference/parse_datetime.html">parse_time</a></span>(<span class="st">"1:00pm"</span>)
<span class="co">#&gt; 13:00:00</span></code></pre></div>
<p>Each function takes a <code>format</code> argument which describes the format of the string. If not specified, it uses a default value:</p>
<ul><li><p><code><a href="../reference/parse_datetime.html">parse_datetime()</a></code> recognises <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO8601</a> datetimes.</p></li>
<li><p><code><a href="../reference/parse_datetime.html">parse_date()</a></code> uses the <code>date_format</code> specified by the <code><a href="../reference/locale.html">locale()</a></code>. The default value is <code>%AD</code> which uses an automatic date parser that recognises dates of the format <code>Y-m-d</code> or <code>Y/m/d</code>.</p></li>
<li><p><code><a href="../reference/parse_datetime.html">parse_time()</a></code> uses the <code>time_format</code> specified by the <code><a href="../reference/locale.html">locale()</a></code>. The default value is <code>%At</code> which uses an automatic time parser that recognises times of the form <code>H:M</code> optionally followed by seconds and am/pm.</p></li>
</ul><p>In most cases, you will need to supply a <code>format</code>, as documented in <code><a href="../reference/parse_datetime.html">parse_datetime()</a></code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/parse_datetime.html">parse_datetime</a></span>(<span class="st">"1 January, 2010"</span>, <span class="st">"%d %B, %Y"</span>)
<span class="co">#&gt; [1] "2010-01-01 UTC"</span>
<span class="kw"><a href="../reference/parse_datetime.html">parse_datetime</a></span>(<span class="st">"02/02/15"</span>, <span class="st">"%m/%d/%y"</span>)
<span class="co">#&gt; [1] "2015-02-02 UTC"</span></code></pre></div>
</div>
<div id="factors" class="section level3">
<h3 class="hasAnchor"><html><body><a href="#factors" class="anchor"> </a></body></html>Factors</h3>
<p>When reading a column that has a known set of values, you can read directly into a factor. <code><a href="../reference/parse_factor.html">parse_factor()</a></code> will generate generate a warning if a value is not in the supplied levels.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/parse_factor.html">parse_factor</a></span>(<span class="kw">c</span>(<span class="st">"a"</span>, <span class="st">"b"</span>, <span class="st">"a"</span>), <span class="dt">levels =</span> <span class="kw">c</span>(<span class="st">"a"</span>, <span class="st">"b"</span>, <span class="st">"c"</span>))
<span class="co">#&gt; [1] a b a</span>
<span class="co">#&gt; Levels: a b c</span>
<span class="kw"><a href="../reference/parse_factor.html">parse_factor</a></span>(<span class="kw">c</span>(<span class="st">"a"</span>, <span class="st">"b"</span>, <span class="st">"d"</span>), <span class="dt">levels =</span> <span class="kw">c</span>(<span class="st">"a"</span>, <span class="st">"b"</span>, <span class="st">"c"</span>))
<span class="co">#&gt; Warning: 1 parsing failure.</span>
<span class="co">#&gt; row col           expected actual</span>
<span class="co">#&gt;   3  -- value in level set      d</span>
<span class="co">#&gt; [1] a    b    &lt;NA&gt;</span>
<span class="co">#&gt; attr(,"problems")</span>
<span class="co">#&gt; # A tibble: 1 &times; 4</span>
<span class="co">#&gt;     row   col           expected actual</span>
<span class="co">#&gt;   &lt;int&gt; &lt;int&gt;              &lt;chr&gt;  &lt;chr&gt;</span>
<span class="co">#&gt; 1     3    NA value in level set      d</span>
<span class="co">#&gt; Levels: a b c</span></code></pre></div>
</div>
</div>
<div id="column-specification" class="section level2">
<h2 class="hasAnchor"><html><body><a href="#column-specification" class="anchor"> </a></body></html>Column specification</h2>
<div id="heuristics" class="section level3">
<h3 class="hasAnchor"><html><body><a href="#heuristics" class="anchor"> </a></body></html>Heuristics</h3>
<p>It would be tedious if you had to specify the type of every column when reading a file. To avoid this problem, readr uses some heuristics to guess the type of each column. You can access these results yourself using <code><a href="../reference/parse_guess.html">guess_parser()</a></code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/parse_guess.html">guess_parser</a></span>(<span class="kw">c</span>(<span class="st">"a"</span>, <span class="st">"b"</span>, <span class="st">"c"</span>))
<span class="co">#&gt; [1] "character"</span>
<span class="kw"><a href="../reference/parse_guess.html">guess_parser</a></span>(<span class="kw">c</span>(<span class="st">"1"</span>, <span class="st">"2"</span>, <span class="st">"3"</span>))
<span class="co">#&gt; [1] "integer"</span>
<span class="kw"><a href="../reference/parse_guess.html">guess_parser</a></span>(<span class="kw">c</span>(<span class="st">"1,000"</span>, <span class="st">"2,000"</span>, <span class="st">"3,000"</span>))
<span class="co">#&gt; [1] "number"</span>
<span class="kw"><a href="../reference/parse_guess.html">guess_parser</a></span>(<span class="kw">c</span>(<span class="st">"2001/10/10"</span>))
<span class="co">#&gt; [1] "date"</span></code></pre></div>
<p>The guessing policies are described in the documentation for the individual functions. Guesses are fairly strict. For example, we don&rsquo;t guess that currencies are numbers, even though we can parse them:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/parse_guess.html">guess_parser</a></span>(<span class="st">"$1,234"</span>)
<span class="co">#&gt; [1] "character"</span>
<span class="kw"><a href="../reference/parse_number.html">parse_number</a></span>(<span class="st">"1,234"</span>)
<span class="co">#&gt; [1] 1234</span></code></pre></div>
<p>The are two parsers that will never be guessed: <code><a href="../reference/col_skip.html">col_skip()</a></code> and <code><a href="../reference/parse_factor.html">col_factor()</a></code>. You will always need to supply these explicitly.</p>
<p>When reading a file, by default readr only looks at the first 1000 rows. This keeps file parsing speedy, but can generate incorrect guesses. For example, take <code>challenge.csv</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">df1 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/read_delim.html">read_csv</a></span>(<span class="kw"><a href="../reference/readr_example.html">readr_example</a></span>(<span class="st">"challenge.csv"</span>))
<span class="co">#&gt; Parsed with column specification:</span>
<span class="co">#&gt; cols(</span>
<span class="co">#&gt;   x = col_integer(),</span>
<span class="co">#&gt;   y = col_character()</span>
<span class="co">#&gt; )</span>
<span class="co">#&gt; Warning: 1000 parsing failures.</span>
<span class="co">#&gt;  row col               expected             actual</span>
<span class="co">#&gt; 1001   x no trailing characters .23837975086644292</span>
<span class="co">#&gt; 1002   x no trailing characters .41167997173033655</span>
<span class="co">#&gt; 1003   x no trailing characters .7460716762579978 </span>
<span class="co">#&gt; 1004   x no trailing characters .723450553836301  </span>
<span class="co">#&gt; 1005   x no trailing characters .614524137461558  </span>
<span class="co">#&gt; .... ... ...................... ..................</span>
<span class="co">#&gt; See problems(...) for more details.</span>
<span class="kw">tail</span>(df1)
<span class="co">#&gt; # A tibble: 6 &times; 2</span>
<span class="co">#&gt;       x          y</span>
<span class="co">#&gt;   &lt;int&gt;      &lt;chr&gt;</span>
<span class="co">#&gt; 1    NA 2019-11-21</span>
<span class="co">#&gt; 2    NA 2018-03-29</span>
<span class="co">#&gt; 3    NA 2014-08-04</span>
<span class="co">#&gt; 4    NA 2015-08-16</span>
<span class="co">#&gt; 5    NA 2020-02-04</span>
<span class="co">#&gt; 6    NA 2019-01-06</span></code></pre></div>
<p>The column types change in row 1001, so readr guesses the wrong types. One way to resolve the problem is to increase the number of rows used to guess the types:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">df2 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/read_delim.html">read_csv</a></span>(<span class="kw"><a href="../reference/readr_example.html">readr_example</a></span>(<span class="st">"challenge.csv"</span>), <span class="dt">guess_max =</span> <span class="dv">1001</span>)
<span class="co">#&gt; Parsed with column specification:</span>
<span class="co">#&gt; cols(</span>
<span class="co">#&gt;   x = col_double(),</span>
<span class="co">#&gt;   y = col_date(format = "")</span>
<span class="co">#&gt; )</span>
<span class="kw">tail</span>(df2)
<span class="co">#&gt; # A tibble: 6 &times; 2</span>
<span class="co">#&gt;           x          y</span>
<span class="co">#&gt;       &lt;dbl&gt;     &lt;date&gt;</span>
<span class="co">#&gt; 1 0.8052743 2019-11-21</span>
<span class="co">#&gt; 2 0.1635163 2018-03-29</span>
<span class="co">#&gt; 3 0.4719390 2014-08-04</span>
<span class="co">#&gt; 4 0.7183186 2015-08-16</span>
<span class="co">#&gt; 5 0.2698786 2020-02-04</span>
<span class="co">#&gt; 6 0.6082372 2019-01-06</span></code></pre></div>
<p>Another way is to specify the <code>col_type</code>, as described below.</p>
</div>
<div id="overriding-the-defaults" class="section level3">
<h3 class="hasAnchor"><html><body><a href="#overriding-the-defaults" class="anchor"> </a></body></html>Overriding the defaults</h3>
<p>In the previous examples, you may have noticed that readr printed the column specification that it used to parse the file:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co">#&gt; Parsed with column specification:</span>
<span class="co">#&gt; cols(</span>
<span class="co">#&gt;   x = col_integer(),</span>
<span class="co">#&gt;   y = col_character()</span>
<span class="co">#&gt; )</span></code></pre></div>
<p>You can also access after the fact using the <code><a href="../reference/cols_condense.html">spec()</a></code> function:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/cols_condense.html">spec</a></span>(df1)
<span class="co">#&gt; cols(</span>
<span class="co">#&gt;   x = col_integer(),</span>
<span class="co">#&gt;   y = col_character()</span>
<span class="co">#&gt; )</span>
<span class="kw"><a href="../reference/cols_condense.html">spec</a></span>(df2)
<span class="co">#&gt; cols(</span>
<span class="co">#&gt;   x = col_double(),</span>
<span class="co">#&gt;   y = col_date(format = "")</span>
<span class="co">#&gt; )</span></code></pre></div>
<p>(This also allows you to access the full column specification if you&rsquo;re reading a very wide file. By default, readr will only print the specification of the first 20 columns.)</p>
<p>If you want to manually specify the column types, you can start by copying and pasting this code:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">df3 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/read_delim.html">read_csv</a></span>(
  <span class="kw"><a href="../reference/readr_example.html">readr_example</a></span>(<span class="st">"challenge.csv"</span>), 
  <span class="dt">col_types =</span> <span class="kw"><a href="../reference/cols.html">cols</a></span>(
    <span class="dt">x =</span> <span class="kw"><a href="../reference/parse_atomic.html">col_double</a></span>(),
    <span class="dt">y =</span> <span class="kw"><a href="../reference/parse_datetime.html">col_date</a></span>(<span class="dt">format =</span> <span class="st">""</span>)
  )
)</code></pre></div>
<p>In general, it&rsquo;s good practice to supply an explicit column specification. It is more work, but it ensures that you get warnings if the data changes in unexpected ways. To be really strict, you can use <code><a href="../reference/problems.html">stop_for_problems(df3)</a></code>. This will throw an error if there are any parsing problems, forcing you to fix those problems before proceeding with the analysis.</p>
<p>It&rsquo;s also possible to generate a specification before you read the file. Each <code>read_</code> function is accompanied by <code>spec_</code> function that returns the specification without full parsing the file:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/spec_delim.html">spec_csv</a></span>(<span class="kw"><a href="../reference/readr_example.html">readr_example</a></span>(<span class="st">"challenge.csv"</span>))
<span class="co">#&gt; Parsed with column specification:</span>
<span class="co">#&gt; cols(</span>
<span class="co">#&gt;   x = col_integer(),</span>
<span class="co">#&gt;   y = col_character()</span>
<span class="co">#&gt; )</span>
<span class="co">#&gt; cols(</span>
<span class="co">#&gt;   x = col_integer(),</span>
<span class="co">#&gt;   y = col_character()</span>
<span class="co">#&gt; )</span></code></pre></div>
<p>For bigger files, you can often make the specification simpler by changing the default column type using <code><a href="../reference/cols_condense.html">cols_condense()</a></code></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">mtcars_spec &lt;-<span class="st"> </span><span class="kw"><a href="../reference/spec_delim.html">spec_csv</a></span>(<span class="kw"><a href="../reference/readr_example.html">readr_example</a></span>(<span class="st">"mtcars.csv"</span>))
<span class="co">#&gt; Parsed with column specification:</span>
<span class="co">#&gt; cols(</span>
<span class="co">#&gt;   mpg = col_double(),</span>
<span class="co">#&gt;   cyl = col_integer(),</span>
<span class="co">#&gt;   disp = col_double(),</span>
<span class="co">#&gt;   hp = col_integer(),</span>
<span class="co">#&gt;   drat = col_double(),</span>
<span class="co">#&gt;   wt = col_double(),</span>
<span class="co">#&gt;   qsec = col_double(),</span>
<span class="co">#&gt;   vs = col_integer(),</span>
<span class="co">#&gt;   am = col_integer(),</span>
<span class="co">#&gt;   gear = col_integer(),</span>
<span class="co">#&gt;   carb = col_integer()</span>
<span class="co">#&gt; )</span>
mtcars_spec
<span class="co">#&gt; cols(</span>
<span class="co">#&gt;   mpg = col_double(),</span>
<span class="co">#&gt;   cyl = col_integer(),</span>
<span class="co">#&gt;   disp = col_double(),</span>
<span class="co">#&gt;   hp = col_integer(),</span>
<span class="co">#&gt;   drat = col_double(),</span>
<span class="co">#&gt;   wt = col_double(),</span>
<span class="co">#&gt;   qsec = col_double(),</span>
<span class="co">#&gt;   vs = col_integer(),</span>
<span class="co">#&gt;   am = col_integer(),</span>
<span class="co">#&gt;   gear = col_integer(),</span>
<span class="co">#&gt;   carb = col_integer()</span>
<span class="co">#&gt; )</span>

<span class="kw"><a href="../reference/cols_condense.html">cols_condense</a></span>(mtcars_spec)
<span class="co">#&gt; cols(</span>
<span class="co">#&gt;   .default = col_integer(),</span>
<span class="co">#&gt;   mpg = col_double(),</span>
<span class="co">#&gt;   disp = col_double(),</span>
<span class="co">#&gt;   drat = col_double(),</span>
<span class="co">#&gt;   wt = col_double(),</span>
<span class="co">#&gt;   qsec = col_double()</span>
<span class="co">#&gt; )</span></code></pre></div>
<p>If you want to read only a subset of the columns, use <code><a href="../reference/cols.html">cols_only()</a></code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">mtcars2 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/read_delim.html">read_csv</a></span>(
  <span class="kw"><a href="../reference/readr_example.html">readr_example</a></span>(<span class="st">"mtcars.csv"</span>),
  <span class="dt">col_types =</span> <span class="kw"><a href="../reference/cols.html">cols_only</a></span>(
    <span class="dt">mpg =</span> <span class="kw"><a href="../reference/parse_atomic.html">col_double</a></span>(),
    <span class="dt">gear =</span> <span class="kw"><a href="../reference/parse_atomic.html">col_integer</a></span>()
  )
)
mtcars2
<span class="co">#&gt; # A tibble: 32 &times; 2</span>
<span class="co">#&gt;      mpg  gear</span>
<span class="co">#&gt;    &lt;dbl&gt; &lt;int&gt;</span>
<span class="co">#&gt; 1   21.0     4</span>
<span class="co">#&gt; 2   21.0     4</span>
<span class="co">#&gt; 3   22.8     4</span>
<span class="co">#&gt; 4   21.4     3</span>
<span class="co">#&gt; 5   18.7     3</span>
<span class="co">#&gt; 6   18.1     3</span>
<span class="co">#&gt; 7   14.3     3</span>
<span class="co">#&gt; 8   24.4     4</span>
<span class="co">#&gt; 9   22.8     4</span>
<span class="co">#&gt; 10  19.2     4</span>
<span class="co">#&gt; # ... with 22 more rows</span></code></pre></div>
</div>
</div>
<div id="rectangular-parsers" class="section level2">
<h2 class="hasAnchor"><html><body><a href="#rectangular-parsers" class="anchor"> </a></body></html>Rectangular parsers</h2>
</div>
<div id="output" class="section level2">
<h2 class="hasAnchor"><html><body><a href="#output" class="anchor"> </a></body></html>Output</h2>
<p><code><a href="../reference/read_delim.html">read_csv()</a></code> produces a data frame with the following properties:</p>
<ul><li><p>Characters are never automatically converted to factors (i.e.&nbsp;no more <code>stringsAsFactors = FALSE</code>).</p></li>
<li><p>Valid column names are left as is, not munged into valid R identifiers (i.e.&nbsp;there is no <code>check.names = TRUE</code>). Missing column names are filled in with <code>X1</code>, <code>X2</code> etc, and duplicated column names are deduplicated.</p></li>
<li><p>The data frame is given class <code>c("tbl_df", "tbl", "data.frame")</code> so if you also use <a href="https://github.com/hadley/dplyr/">dplyr</a> you&rsquo;ll get an enhanced display.</p></li>
<li><p>Row names are never set.</p></li>
</ul></div>
<div id="problems" class="section level2">
<h2 class="hasAnchor"><html><body><a href="#problems" class="anchor"> </a></body></html>Problems</h2>
<p>If there are any problems parsing the file, the <code>read_</code> function will throw a warning telling you how many problems there are. You can then use the <code><a href="../reference/problems.html">problems()</a></code> function to access a data frame that gives information about each problem:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">df &lt;-<span class="st"> </span><span class="kw"><a href="../reference/read_delim.html">read_csv</a></span>(<span class="dt">col_types =</span> <span class="st">"dd"</span>, <span class="dt">col_names =</span> <span class="kw">c</span>(<span class="st">"x"</span>, <span class="st">"y"</span>), <span class="dt">skip =</span> <span class="dv">1</span>, <span class="st">"</span>
<span class="st">1,2</span>
<span class="st">a,b</span>
<span class="st">"</span>)
<span class="co">#&gt; Warning message: There were 2 problems. See problems(x) for more details</span>
<span class="kw"><a href="../reference/problems.html">problems</a></span>(df)
<span class="co">#&gt;   row col expected actual</span>
<span class="co">#&gt; 1   2   1 a double      a</span>
<span class="co">#&gt; 2   2   2 a double      b</span></code></pre></div>
<p>It&rsquo;s likely that there will be cases that you can never load without some manual regexp-based munging in R. Load those columns with <code><a href="../reference/parse_atomic.html">col_character()</a></code>, fix them up as needed, then use <code>convert_types()</code> to re-run the automated conversion on every character column in the data frame. Alternatively, you can use <code><a href="../reference/parse_atomic.html">parse_integer()</a></code>, <code>parse_numeric()</code>, <code><a href="../reference/parse_datetime.html">parse_date()</a></code> etc to parse a single character vector at a time.</p>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
        <div id="tocnav">
      <h2>Contents</h2>
      <ul class="nav nav-pills nav-stacked"><li><a href="#vector-parsers">Vector parsers</a></li>
      <li><a href="#column-specification">Column specification</a></li>
      <li><a href="#rectangular-parsers">Rectangular parsers</a></li>
      <li><a href="#output">Output</a></li>
      <li><a href="#problems">Problems</a></li>
      </ul></div>
      </div>

</div>


      <footer><div class="tidyverse">
  <p>readr is a part of the <strong>tidyverse</strong>, an ecosystem of packages designed with common APIs and a shared philosophy. Learn more at <a href="http://tidyverse.org">tidyverse.org</a>.</p>
</div>

<div class="author">
  <p>Developed by <a href="http://hadley.nz">Hadley Wickham</a>, Jim Hester, Romain Francois, <a href="https://www.rstudio.com"><img src="http://tidyverse.org/rstudio-logo.svg" height="24"></a>, Jukka Jyl&auml;nki, Mikkel J&oslash;rgensen.</p>
  <p>Site built by <a href="http://hadley.github.io/pkgdown/">pkgdown</a>.</p>
</div>
      </footer></div>

  </body></html>
